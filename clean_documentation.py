# Some documentation files generated by DeepSeek contain <think> tags
# that are not useful for end users. This script removes those tags


import re
import sys
import argparse
from pathlib import Path

DOCS_DIR_NAME = "_llm_docs"

def remove_think_tags(content: str) -> str:
    """
    Remove all <think>...</think> blocks from the content.
    Handles multi-line think blocks.
    """
    # Pattern to match <think>...</think> including newlines
    pattern = r'<think>.*?</think>'
    cleaned = re.sub(pattern, '', content, flags=re.DOTALL)
    
    # Clean up multiple consecutive blank lines that may result
    cleaned = re.sub(r'\n{3,}', '\n\n', cleaned)
    
    return cleaned.strip() + '\n'

def clean_documentation_file(file_path: Path, dry_run: bool = False) -> bool:
    """
    Clean a single documentation file by removing <think> tags.
    Returns True if changes were made, False otherwise.
    """
    try:
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            original_content = f.read()
        
        # Check if file contains <think> tags
        if '<think>' not in original_content:
            return False
        
        cleaned_content = remove_think_tags(original_content)
        
        if dry_run:
            print(f"[DRY RUN] Would clean: {file_path}")
            return True
        
        # Write cleaned content back
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(cleaned_content)
        
        print(f"Cleaned: {file_path}")
        return True
        
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return False

def process_directory(dir_path: Path, dry_run: bool = False) -> tuple[int, int]:
    """
    Recursively process all _llm_docs directories and clean documentation files.
    Returns tuple of (files_processed, files_cleaned).
    """
    files_processed = 0
    files_cleaned = 0
    
    # Look for _llm_docs directory in current directory
    docs_dir = dir_path / DOCS_DIR_NAME
    if docs_dir.exists() and docs_dir.is_dir():
        # Process all .txt files in the docs directory
        for file in docs_dir.glob("*.txt"):
            files_processed += 1
            if clean_documentation_file(file, dry_run):
                files_cleaned += 1
    
    # Recurse into subdirectories
    for entry in dir_path.iterdir():
        if entry.is_dir() and entry.name != DOCS_DIR_NAME:
            sub_processed, sub_cleaned = process_directory(entry, dry_run)
            files_processed += sub_processed
            files_cleaned += sub_cleaned
    
    return files_processed, files_cleaned

def main():
    parser = argparse.ArgumentParser(
        description="Clean documentation files by removing <think> tags from DeepSeek model output."
    )
    parser.add_argument(
        "root", 
        nargs="?", 
        default=None, 
        help="Root directory to process (default: current directory)"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true", 
        help="Show what would be cleaned without making changes"
    )
    
    args = parser.parse_args()
    
    root = Path(args.root).resolve() if args.root else Path.cwd()
    
    if not root.exists() or not root.is_dir():
        print(f"Error: The specified root path '{root}' does not exist or is not a directory.")
        sys.exit(1)
    
    if args.dry_run:
        print("DRY RUN MODE: No files will be modified\n")
    
    print(f"Cleaning documentation in: {root}\n")
    
    files_processed, files_cleaned = process_directory(root, args.dry_run)
    
    print(f"\n{'='*50}")
    print(f"Summary:")
    print(f"  Files processed: {files_processed}")
    print(f"  Files cleaned: {files_cleaned}")
    print(f"  Files unchanged: {files_processed - files_cleaned}")
    
    if args.dry_run:
        print(f"\nThis was a dry run. Run without --dry-run to apply changes.")
    else:
        print(f"\nCleaning complete!")

if __name__ == "__main__":
    main()
